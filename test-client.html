<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice AI — Test Client</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f8f9fb;
    --surface: #ffffff;
    --surface-2: #f1f3f5;
    --border: #e2e5ea;
    --text-primary: #1a1d21;
    --text-secondary: #5f6368;
    --text-muted: #9aa0a8;
    --accent: #2563eb;
    --accent-light: #eff4ff;
    --green: #16a34a;
    --green-light: #f0fdf4;
    --red: #dc2626;
    --red-light: #fef2f2;
    --amber: #d97706;
    --amber-light: #fffbeb;
    --shadow-md: 0 4px 12px rgba(0,0,0,0.06);
    --radius: 16px;
    --radius-sm: 10px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
  }

  .container { width: 460px; padding: 32px; }

  /* Header */
  .header { text-align: center; margin-bottom: 36px; }
  .header .brand {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 6px;
  }
  .brand-icon {
    width: 36px; height: 36px;
    background: var(--accent);
    border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
  }
  .brand-icon svg { color: #fff; }
  .header h1 {
    font-size: 1.25rem; font-weight: 700;
    letter-spacing: -0.02em;
  }
  .header p {
    font-size: 0.8rem; color: var(--text-muted); font-weight: 400;
  }

  /* Card */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow-md);
    overflow: hidden;
  }

  .call-section {
    padding: 32px 24px;
    display: flex; flex-direction: column;
    align-items: center; gap: 20px;
  }

  /* Call button */
  .call-btn {
    width: 80px; height: 80px; border-radius: 50%;
    border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s ease;
    position: relative;
  }
  .call-btn svg { width: 28px; height: 28px; color: #fff; }
  .call-btn:active { transform: scale(0.95); }

  .call-btn.idle {
    background: var(--green);
    box-shadow: 0 4px 16px rgba(22,163,74,0.3);
  }
  .call-btn.idle:hover {
    box-shadow: 0 6px 20px rgba(22,163,74,0.4);
    transform: translateY(-1px);
  }
  .call-btn.active {
    background: var(--red);
    box-shadow: 0 4px 16px rgba(220,38,38,0.3);
  }
  .call-btn.active:hover {
    box-shadow: 0 6px 20px rgba(220,38,38,0.4);
    transform: translateY(-1px);
  }
  .call-btn.active::before {
    content: '';
    position: absolute;
    width: 100%; height: 100%;
    border-radius: 50%;
    border: 2px solid var(--red);
    animation: ring-pulse 2s ease-out infinite;
  }
  @keyframes ring-pulse {
    0% { transform: scale(1); opacity: 0.5; }
    100% { transform: scale(1.6); opacity: 0; }
  }

  /* Status badge */
  .status-badge {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 6px 14px; border-radius: 20px;
    font-size: 0.78rem; font-weight: 500;
    transition: all 0.3s ease;
  }
  .status-badge.idle { background: var(--surface-2); color: var(--text-muted); }
  .status-badge.listening { background: var(--green-light); color: var(--green); }
  .status-badge.speaking { background: var(--accent-light); color: var(--accent); }
  .status-badge.waiting { background: var(--amber-light); color: var(--amber); }
  .status-badge.ended { background: var(--red-light); color: var(--red); }

  .status-dot {
    width: 6px; height: 6px;
    border-radius: 50%; background: currentColor;
  }
  .status-badge.listening .status-dot,
  .status-badge.speaking .status-dot {
    animation: dot-blink 1.2s ease-in-out infinite;
  }
  @keyframes dot-blink {
    0%, 100% { opacity: 1; } 50% { opacity: 0.3; }
  }

  /* Waveform */
  .waveform-wrap { width: 100%; padding: 0 4px; }
  canvas {
    width: 100%; height: 56px;
    border-radius: var(--radius-sm);
    background: var(--surface-2);
  }

  .divider { height: 1px; background: var(--border); }

  /* Log */
  .log-section { padding: 16px; }
  .log-header {
    display: flex; align-items: center;
    justify-content: space-between; margin-bottom: 10px;
  }
  .log-header span {
    font-size: 0.7rem; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.06em;
    color: var(--text-muted);
  }
  .log-clear {
    font-size: 0.65rem; color: var(--text-muted);
    background: none; border: none; cursor: pointer;
    padding: 2px 6px; border-radius: 4px;
    font-family: inherit; transition: all 0.15s;
  }
  .log-clear:hover { background: var(--surface-2); color: var(--text-secondary); }

  .log-area {
    max-height: 200px; overflow-y: auto;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem; line-height: 1.7;
    scrollbar-width: thin; scrollbar-color: var(--border) transparent;
  }
  .log-area::-webkit-scrollbar { width: 4px; }
  .log-area::-webkit-scrollbar-track { background: transparent; }
  .log-area::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .log-area .entry {
    display: flex; gap: 8px; padding: 1px 0;
    animation: log-in 0.2s ease;
  }
  @keyframes log-in {
    from { opacity: 0; transform: translateY(4px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .log-area .ts { color: var(--text-muted); flex-shrink: 0; }
  .log-area .msg { color: var(--text-secondary); }
  .log-area .msg.info { color: var(--accent); }
  .log-area .msg.sent { color: var(--green); }
  .log-area .msg.recv { color: var(--amber); }
  .log-area .msg.err { color: var(--red); }
  .log-empty {
    text-align: center; padding: 20px;
    color: var(--text-muted); font-size: 0.72rem;
    font-family: 'Inter', sans-serif;
  }
  .footer {
    text-align: center; margin-top: 16px;
    font-size: 0.7rem; color: var(--text-muted);
  }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">
      <div class="brand-icon">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/>
        </svg>
      </div>
      <h1>Voice AI</h1>
    </div>
    <p>Browser test client &mdash; direct WebSocket connection</p>
  </div>

  <div class="card">
    <div class="call-section">
      <button class="call-btn idle" id="callBtn" onclick="toggleCall()">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
        </svg>
      </button>

      <div class="status-badge idle" id="statusBadge">
        <span class="status-dot"></span>
        <span id="statusText">Tap to start a call</span>
      </div>

      <div class="waveform-wrap">
        <canvas id="waveform" width="800" height="112"></canvas>
      </div>
    </div>

    <div class="divider"></div>

    <div class="log-section">
      <div class="log-header">
        <span>Activity Log</span>
        <button class="log-clear" onclick="clearLog()">Clear</button>
      </div>
      <div class="log-area" id="log">
        <div class="log-empty">No activity yet</div>
      </div>
    </div>
  </div>

  <div class="footer">ws://localhost:3000/media-stream</div>
</div>

<script>
const ICON_PHONE = `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>`;
const ICON_HANGUP = `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6A19.79 19.79 0 0 1 2.12 4.11 2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"/><line x1="2" y1="2" x2="22" y2="22"/></svg>`;

const SERVER_PORT = 3000;
const WS_URL = `ws://${location.hostname}:${SERVER_PORT}/media-stream`;
const SAMPLE_RATE = 8000;
const CHUNK_MS = 20;
const CHUNK_SIZE = (SAMPLE_RATE * CHUNK_MS) / 1000;

let ws = null, audioCtx = null, micStream = null, scriptNode = null;
let active = false, streamSid = '';
let playbackQueue = [], isPlaying = false;
let micEnabled = false, pendingMarks = [];

const callBtn = document.getElementById('callBtn');
const statusBadge = document.getElementById('statusBadge');
const statusText = document.getElementById('statusText');
const logEl = document.getElementById('log');
const canvas = document.getElementById('waveform');
const canvasCtx = canvas.getContext('2d');

function setStatus(text, state) {
  statusText.textContent = text;
  statusBadge.className = `status-badge ${state}`;
}

function addLog(text, cls = '') {
  const empty = logEl.querySelector('.log-empty');
  if (empty) empty.remove();
  const d = document.createElement('div');
  d.className = 'entry';
  const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  d.innerHTML = `<span class="ts">${ts}</span><span class="msg ${cls}">${text}</span>`;
  logEl.appendChild(d);
  logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
  logEl.innerHTML = '<div class="log-empty">No activity yet</div>';
}

// ── Mulaw codec ─────────────────────────────────────────────
const MULAW_BIAS = 33, MULAW_MAX = 32635;

function linearToMulaw(sample) {
  sample = Math.max(-32768, Math.min(32767, sample));
  const sign = (sample < 0) ? 0x80 : 0;
  if (sample < 0) sample = -sample;
  sample = Math.min(sample + MULAW_BIAS, MULAW_MAX);
  const exp = [0,1,2,3,4,5,6,7].find(e => sample < (0x84 << e)) ?? 7;
  const mantissa = (sample >> (exp + 3)) & 0x0F;
  return ~(sign | (exp << 4) | mantissa) & 0xFF;
}

function mulawToLinear(byte) {
  byte = ~byte & 0xFF;
  const sign = byte & 0x80;
  const exp = (byte >> 4) & 0x07;
  const mantissa = byte & 0x0F;
  let sample = ((mantissa << 4) + 0x84) << exp;
  sample -= MULAW_BIAS * 4;
  return sign ? -sample : sample;
}

// ── Waveform ────────────────────────────────────────────────
let vizData = new Float32Array(128).fill(0);
const W = canvas.width, H = canvas.height;

function drawWaveform() {
  if (!active) {
    canvasCtx.fillStyle = '#f1f3f5';
    canvasCtx.fillRect(0, 0, W, H);
    canvasCtx.strokeStyle = '#d5d9df';
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.moveTo(0, H / 2);
    canvasCtx.lineTo(W, H / 2);
    canvasCtx.stroke();
    return;
  }
  requestAnimationFrame(drawWaveform);
  canvasCtx.fillStyle = '#f1f3f5';
  canvasCtx.fillRect(0, 0, W, H);

  const grad = canvasCtx.createLinearGradient(0, 0, W, 0);
  grad.addColorStop(0, '#2563eb');
  grad.addColorStop(0.5, '#7c3aed');
  grad.addColorStop(1, '#2563eb');

  canvasCtx.strokeStyle = grad;
  canvasCtx.lineWidth = 2;
  canvasCtx.lineJoin = 'round';
  canvasCtx.beginPath();
  const slice = W / vizData.length;
  let x = 0;
  for (let i = 0; i < vizData.length; i++) {
    const y = (0.5 + vizData[i] * 0.45) * H;
    i === 0 ? canvasCtx.moveTo(x, y) : canvasCtx.lineTo(x, y);
    x += slice;
  }
  canvasCtx.stroke();

  canvasCtx.globalAlpha = 0.08;
  canvasCtx.strokeStyle = grad;
  canvasCtx.beginPath();
  x = 0;
  for (let i = 0; i < vizData.length; i++) {
    const y = H - (0.5 + vizData[i] * 0.45) * H;
    i === 0 ? canvasCtx.moveTo(x, y) : canvasCtx.lineTo(x, y);
    x += slice;
  }
  canvasCtx.stroke();
  canvasCtx.globalAlpha = 1;
}
drawWaveform();

function resample(input, fromRate, toRate) {
  const ratio = fromRate / toRate;
  const len = Math.floor(input.length / ratio);
  const out = new Float32Array(len);
  for (let i = 0; i < len; i++) {
    const srcIdx = i * ratio;
    const idx = Math.floor(srcIdx);
    const frac = srcIdx - idx;
    out[i] = (input[idx] || 0) + frac * ((input[idx + 1] || 0) - (input[idx] || 0));
  }
  return out;
}

async function toggleCall() {
  if (active) endCall();
  else await startCall();
}

async function startCall() {
  try {
    addLog('Requesting microphone access', 'info');
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true, sampleRate: SAMPLE_RATE }
    });
    const micRate = micStream.getAudioTracks()[0].getSettings().sampleRate || 48000;
    addLog(`Microphone opened at ${micRate} Hz`, 'info');
    audioCtx = new AudioContext({ sampleRate: micRate });

    streamSid = 'WEB_' + Math.random().toString(36).slice(2, 10);
    addLog('Connecting to server', 'info');
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      addLog('WebSocket connected', 'info');
      active = true;
      callBtn.className = 'call-btn active';
      callBtn.innerHTML = ICON_HANGUP;
      setStatus('Greeting...', 'waiting');
      drawWaveform();

      ws.send(JSON.stringify({ event: 'connected', protocol: 'Call', version: '1.0.0' }));
      ws.send(JSON.stringify({
        event: 'start', streamSid,
        start: {
          streamSid,
          callSid: 'CA_browser_' + Date.now().toString(36),
          customParameters: { callerNumber: '+0000000000' },
          mediaFormat: { encoding: 'audio/x-mulaw', sampleRate: '8000', channels: '1' }
        }
      }));
      addLog('Stream started', 'sent');

      micEnabled = false;
      startMicCapture(micRate);

      setTimeout(() => {
        if (!micEnabled && active) {
          micEnabled = true;
          setStatus('Listening', 'listening');
          addLog('Mic enabled (timeout)', 'info');
        }
      }, 8000);
    };

    ws.onmessage = (evt) => {
      const data = JSON.parse(evt.data);
      if (data.event === 'media' && data.media?.payload) {
        const raw = atob(data.media.payload);
        const mulaw = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) mulaw[i] = raw.charCodeAt(i);
        queuePlayback(mulaw);
        if (active) setStatus('AI speaking', 'speaking');
      }
      else if (data.event === 'mark') {
        pendingMarks.push(data.mark.name);
      }
      else if (data.event === 'clear') {
        addLog('Playback cleared', 'recv');
        playbackQueue = [];
      }
    };

    ws.onclose = () => { addLog('Connection closed', 'info'); endCall(); };
    ws.onerror = () => { addLog('Connection failed', 'err'); endCall(); };
  } catch (err) {
    addLog(`Error: ${err.message}`, 'err');
    endCall();
  }
}

function startMicCapture(micRate) {
  const source = audioCtx.createMediaStreamSource(micStream);
  scriptNode = audioCtx.createScriptProcessor(4096, 1, 1);

  scriptNode.onaudioprocess = (e) => {
    if (!active || !ws || ws.readyState !== 1 || !micEnabled) return;

    const input = e.inputBuffer.getChannelData(0);
    const step = Math.floor(input.length / vizData.length);
    for (let i = 0; i < vizData.length; i++) vizData[i] = input[i * step] || 0;

    let sumSq = 0;
    for (let i = 0; i < input.length; i++) sumSq += input[i] * input[i];
    const rms = Math.sqrt(sumSq / input.length);

    const resampled = resample(input, micRate, SAMPLE_RATE);

    if (rms < 0.008) {
      const sil = new Uint8Array(CHUNK_SIZE).fill(0xFF);
      const b64 = btoa(String.fromCharCode(...sil));
      ws.send(JSON.stringify({ event: 'media', streamSid, media: { payload: b64 } }));
      return;
    }

    const mulawBuf = new Uint8Array(resampled.length);
    for (let i = 0; i < resampled.length; i++) {
      const s16 = Math.max(-32768, Math.min(32767, Math.round(resampled[i] * 32767)));
      mulawBuf[i] = linearToMulaw(s16);
    }

    for (let i = 0; i < mulawBuf.length; i += CHUNK_SIZE) {
      const chunk = mulawBuf.slice(i, Math.min(i + CHUNK_SIZE, mulawBuf.length));
      const b64 = btoa(String.fromCharCode(...chunk));
      ws.send(JSON.stringify({ event: 'media', streamSid, media: { payload: b64 } }));
    }
  };

  source.connect(scriptNode);
  scriptNode.connect(audioCtx.destination);
}

function queuePlayback(mulawBytes) {
  playbackQueue.push(mulawBytes);
  if (!isPlaying) drainPlayback();
}

function drainPlayback() {
  if (!audioCtx || playbackQueue.length === 0) { isPlaying = false; return; }
  isPlaying = true;

  let total = 0;
  for (const c of playbackQueue) total += c.length;
  const merged = new Uint8Array(total);
  let off = 0;
  for (const c of playbackQueue) { merged.set(c, off); off += c.length; }
  playbackQueue = [];

  const pcm = new Float32Array(merged.length);
  for (let i = 0; i < merged.length; i++) pcm[i] = mulawToLinear(merged[i]) / 32768;

  const playRate = audioCtx.sampleRate;
  const upsampled = resample(pcm, SAMPLE_RATE, playRate);
  const buf = audioCtx.createBuffer(1, upsampled.length, playRate);
  buf.getChannelData(0).set(upsampled);

  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx.destination);
  src.start();

  src.onended = () => {
    if (playbackQueue.length > 0) { drainPlayback(); return; }
    isPlaying = false;
    while (pendingMarks.length > 0) {
      const name = pendingMarks.shift();
      if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ event: 'mark', streamSid, mark: { name } }));
      }
      if (!micEnabled) {
        micEnabled = true;
        addLog('Greeting finished — mic active', 'info');
      }
    }
    if (active) setStatus('Listening', 'listening');
  };
}

function endCall() {
  active = false;
  callBtn.className = 'call-btn idle';
  callBtn.innerHTML = ICON_PHONE;
  setStatus('Call ended', 'ended');
  drawWaveform();

  if (ws && ws.readyState === 1) {
    ws.send(JSON.stringify({ event: 'stop', streamSid, stop: { callSid: 'CA_browser' } }));
    ws.close();
  }
  ws = null;
  if (scriptNode) { scriptNode.disconnect(); scriptNode = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (audioCtx) { audioCtx.close(); audioCtx = null; }
  playbackQueue = []; isPlaying = false;
  micEnabled = false; pendingMarks = [];

  setTimeout(() => { if (!active) setStatus('Tap to start a call', 'idle'); }, 3000);
}
</script>
</body>
</html>
